unit class CSS::DOM;

# maintains associations between CSS Selectors and a XML/HTML DOM
# no lazyness or other optimisations yet

use CSS::Stylesheet;
use CSS::Properties;
use CSS::Properties::Units :px;
use CSS::Media;
use LibXML::Document :HTML;
use LibXML::Node;

has CSS::Media $.media .= new: :type<tty>, :width(480px), :height(640px);
has LibXML::Document:D $.doc is required;
has CSS::Stylesheet $!stylesheet;
has Array %.props;
has Bool $.inline;

# apply selectors (no inheritance)
method !build {
    $!doc.indexElements;
    # todo - proper media selection;
    for $!stylesheet.rules.grep({.media ~~ $!media.type|'all'}) {
        for $!doc.findnodes(.xpath) {
            %!props{.nodePath}.push: $_;
        }
    }
    $!inline //= ?($!doc ~~ HTML);
    if $!inline {
        # locate and parse inline styles
        for $!doc.findnodes('//@style') {
            my $path = .ownerElement.nodePath;
            my $style = .value;
            %!props{$path}.push: CSS::Properties.new(:$style);
        }
    }
}

multi submethod TWEAK(CSS::Stylesheet :style($!stylesheet)!) {
    self!build();
}

multi submethod TWEAK(Str:D :style($string)!) {
    $!stylesheet .= parse($string);
    self!build();
}

multi submethod TWEAK(HTML :doc($)!) {
    my $string = '';
    my @styles = $!doc<html/head/style>.map(*.textContent);
    $!stylesheet .= parse(@styles.join: "\n");
    self!build();
}

# compute the style of an individual element
method style(LibXML::Element $elem) {
}

